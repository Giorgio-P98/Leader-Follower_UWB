\subsection{Offboard control node}
The heart of the following algorithm, as already mentioned resides in the Raspberry Pi 4 and it is the offboard control node. In particular, the tasks that it performs are the following: 
\begin{itemize}
    \item when started, it subscribes to all the required topics (flight controller state estimates, vehicle status and UWB readings) and it creates even all the required publishers that communicate with the FC ( vehicle commands and offboard heartbeat signal\footnote{The offboard heartbeat signal is a specific "proof of life" message that has to be sent at least with a frequency of 2 Hz to stay in offboard mode, otherwise PX4 will switch in position mode.}). Then it creates a timer with period $dt=0.1$ seconds that serves as a endless loop (except in case of program termination) in which at every step the setpoints are sent to the FC. In the main loop there are two different modalities, according to the value of a flag of the node: takeoff and following. The flag is initiated in takeoff mode. However, in both the modes the offboard heartbeat signal is sent once per step.
    \item when the main loop starts, the quadcopter executes a takeoff at the wanted height. This is done by sending to the FC the position setpoint $X_{sp}=\begin{bmatrix} 0,0,z_{w} \end{bmatrix}^T$. Since when the flight controller starts up it set the global origin where it is located, it is a simple vertical takeoff. The takeoff is considered done when the drone position estimate is within a tolerance near to the setpoint. At that time the flag switches to following mode.
    \item once in following mode, at every time step the control law explained in \autoref{control_law} is employed to compute the setpoints needed to follow the target. To do so, it takes the UWB topic values (i.e. the last measured range and AoA) published by the sensor node, that will be later described, and calculate the controls as explained.
    Since in ROS2 topic's values remains equal until they are changed by a publisher, the offboard node, if for unforeseen reasons the UWB sensor do not update the measure, keep the old value until it is changed. If we fool in this situation our control strategy is divided into three cases:
    \begin{itemize}
        \item If the taken message remains equal for $n_{msg_{0}}$ time steps, the offboard node command a hoovering. This is done sending null x and y velocity setpoints, $z_{w}$ as z position and $\psi_{k_{estim}}$ as yaw;
        \item If the messages still remain identical for more then $n_{msg_{l}}$ steps, the node command the FC to land on the spot and disarm;
        \item Until the message remains equal for less then $n_{msg{0}}$ steps, the control is performed normally using the last values.
    \end{itemize}
    The described behaviour lasts until the drone is disarmed due to the absence of UWB messages or until a manual exit from the offboard mode commanded by the radio controller.
\end{itemize}

\subsection{UWB sensor node}
The double-antenna UWB module has its own microcontroller on which the proprietary firmware runs. It communicates the range and angle sensor readings to the Raspberry via serial communication.\\
To exploit the flexibility of ROS2, we decided to create a node on the mission computer that parses the serial communication to extract the values of interest and publish them, with a frequency of $10 Hz$ using a custom ROS2 message that contains the fields range and AoA, on the UWB custom topic.\\
If no new sensor readings are received, that is when the serial communication with the microcontroller stops or in the eventuality of parsing errors, the node does not publish anything. In this way, the offboard control node, that holds memory of the last received message, realizes if new information are available and if the UWB sensor works properly.  

\subsection{Mocap bridge pose node} \label{Mocap details}
In the case of indoor flight with a motion capture system, it is necessary to provide Mocap's pose estimate of the drone to the flight controller in order to fly. This is done with a free-to-use Qualisys node \cite{qualisysros} executed on a device that shares the network of the PC on which the motion capture system runs. The pose of all the bodies defined and tracked in the MoCap system is collected and published.\\
With another node, called bridge, we simply subscribe and publish to the dedicated input topic of the flight controller. Inside this bridge node is also possible to manipulate the content of the Qualisys' topics to use a custom global reference frame, and send this data to the FC. In our case we keep the mocap axis orientation and translate the origin of the global frame in the position of the drone before the takeoff.